---
title: "Data Gather"
author: "James Keane"
date: "10/4/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=FALSE}
library(ape)
library(FRK)
library(readr)
library(dplyr)
library("sp")
library("spacetime")
library("animation")
library("ggplot2")
library("gstat")
library("maps")
library("STRbook")
library("grid")
library("gridExtra")
library(lubridate)
library(skimr)
library(zoo)
library(tidyverse)
```




```{r}
measures <- read_delim("2020_data.csv", "|", escape_double = FALSE, trim_ws = TRUE)
names(measures) = c("loc", "date", "value", "lat", "lon")
measures$value = log(measures$value + 1)


measures$t = yday(measures$date)

measures = measures %>% filter(lon > -20 & lon < 20, lat >40, date != '2021-01-01')
a <- measures %>% select(-lon, -lat) %>% pivot_wider(date, loc)
b <- skim(a)
missing <- b$skim_variable[b$complete_rate < 0.95]
a =  na.aggregate(a, FUN = function(x) mean(as.numeric(as.character(x))))


a = a %>% pivot_longer(cols=colnames(a)[-1], names_to="loc")
a = a %>% filter(!loc %in% missing)
measures <- measures %>% filter(!loc %in% missing)
locations = measures %>% distinct(loc, .keep_all=TRUE) %>% dplyr::select(loc, lat, lon)

measures = locations %>% left_join(a, by=c("loc" = "loc"))

measures$value = as.numeric(measures$value)

measures$date = as.Date(measures$date)
measures$t = yday(measures$date)
```



```{r}
filt <- measures %>% filter(date >= as.Date("2020-02-01") & date <= as.Date("2020-02-08"))

base_plot <- ggplot(filt) +             # plot points
    geom_point(aes(x = lon, y = lat,       # lon and lat
                   colour = value),           # attribute color
               size = 2) +                # make all points larger
    col_scale(name = "PM2.5") +            # attach color scale
    xlab("Longitude (deg)") +             # x-axis label
    ylab("Latitude (deg)") +              # y-axis label
    geom_path(data = map_data('france'),   # add US states map
          aes(x = long, y = lat, group = group)) +
    facet_wrap(~date, nrow=2) +               # facet by time
    coord_fixed(xlim = c(-5, 10),
                ylim = c(41, 53))  +      # zoom in
    theme_bw()                            # B&W theme

base_plot
```



```{r}
mean_set = measures %>% group_by(date) %>% summarise(value=mean(value))

TmaxTS <- ggplot(measures) +
    geom_line(aes(x = date, y = value, group=loc), alpha=.05, size=.2, colour='black') +
    geom_line(data=mean_set, aes(x=date, y=value), size=0.25, color='red') + 
    theme(panel.grid=element_blank()) +
    xlab("Date") +    # x label
    ylab("Pm2.5") 

TmaxTS 
```


```{r}
lim_lat <- range(measures$lon)        # latitude range
lim_t <- range(measures$t)            # time range
lat_axis <- seq(lim_lat[1],       # latitude axis
                lim_lat[2],
                length=25)
t_axis <- seq(lim_t[1],           # time axis
              lim_t[2],
              length=50)
lat_t_grid <- expand.grid(lat = lat_axis,
                          t = t_axis)

Airq_grid <- measures
dists <- abs(outer(measures$lon, lat_axis, "-"))
Airq_grid$lat <- lat_axis[apply(dists, 1, which.min)]

Airq_lat_Hov <- group_by(Airq_grid,across(all_of(c("lat","t")))) %>%
                summarise(value = mean(value))

```


```{r}

Hovmoller_lat <- ggplot(Airq_lat_Hov) +            # take data
        geom_tile(aes(x = lat, y = t, fill = value)) + # plot
        fill_scale(name = "pm2.5") +     # add color scale
        scale_y_reverse() +             # rev y scale
        ylab("Day number (days)") +     # add y label
        xlab("Latitude (degrees)") +    # add x label
        theme_bw()                      # change theme

Hovmoller_lat
```


```{r}
spat_av <- measures %>% group_by(loc) %>%    # group by lon-lat
           summarise_all(mean)     # mean for each lon-lat

lat_means <- ggplot(spat_av) +
             geom_point(aes(lat, value)) +
             xlab("Latitude (deg)") +
             ylab("Maximum temperature (degF)") + theme_bw()
lat_means

lon_means <- ggplot(spat_av) +
             geom_point(aes(lon, value)) +
             xlab("Longitude (deg)") +
             ylab("Maximum temperature (degF)") + theme_bw() 

lon_means

```



```{r}
lm1 <- lm(value ~1, data = measures) # fit a linear model
measures$residuals <- residuals(lm1)  


```



```{r}


spat_df <- filter(measures, date == '2020-12-31') %>% # lon/lat coords of stations
            dplyr::select(lon, lat)  %>%   # select lon/lat only
            arrange(lon, lat)       # sort ascending by lon/lat
m <- nrow(spat_av)                  # number of stations

## ------------------------------------------------------------------------
X <- dplyr::select(measures, loc, residuals, t) %>% # select columns
     spread(t, residuals) %>%
     dplyr::select(-loc) %>%                   # drop coord info
     t()                                      # make space-wide

## ------------------------------------------------------------------------
Lag0_cov <- cov(X, use = 'complete.obs')
Lag1_cov <- cov(X[-1, ], X[-nrow(X),], use = 'complete.obs')

## ------------------------------------------------------------------------
spat_df$n <- 1:nrow(spat_df)    # assign an index to each station
lim_lon <- range(spat_df$lon)   # range of lon coordinates
lon_strips <- seq(lim_lon[1],   # create 4 long. strip boundaries
                  lim_lon[2],
                  length = 5)
spat_df$lon_strip <- cut(spat_df$lon,     # bin the lon into
                         lon_strips,      # their respective bins
                         labels = FALSE,  # don't assign labels
                         include.lowest = TRUE) # include edges
```


```{r}
plot_cov_strips2 <- function(C,spat_df) {  
    # for each longitudinal strip 
    require(fields)   # load fields for plotting
    for(i in seq_along(unique(spat_df$lon_strip))){                        
        spat_strip <- spat_df %>%         # take spat_df
            filter(lon_strip == i)  %>%   # extract the ith strip
            arrange(lat)                  # sort by latitude
        idx <- spat_strip$n               # extract indices of locations
        jitter <- seq(0,0.0001,           # add jitter for locations that
                      length=length(idx)) # have same latitude component
        image.plot(spat_strip$lat+jitter, # plot the matrix using fields
                   spat_strip$lat+jitter,
                   C[idx,idx],            # subset and permute C
                   xlab="latitude",
                   ylab="latitude",
                   col=tim.colors(10),
                   cex=200)
    }
}
```


```{r}

par(mfrow=c(2,4))
## ------------------------------------------------------------------------
head(spat_df)   # print the first 6 records of spat_df

plot_cov_strips2(Lag0_cov, spat_df)  # plot the lag-0 matrices
plot_cov_strips2(Lag1_cov, spat_df)  # plot the lag-1 matrices


## ------------------------------------------------------------------------
```

```{r}
spat_part <- SpatialPoints(coords=  locations[,c("lon","lat")])
temp_part <- seq(as.Date("2020-01-01"), by = "day", length.out = 366)
long_data <- measures %>% arrange(date)

temp_part = temp_part[-c(which(!temp_part %in% unique(long_data$date)))]

STObj <- STFDF(sp = spat_part,
               time = temp_part,
               data = long_data)

proj4string(STObj) <- CRS("+proj=longlat +ellps=WGS84")

vv <- variogram(object = value~1, # fixed effect component
    data = STObj, # July data
    width = 50, # spatial bin (80 km)
    cutoff = 100, # consider pts < 1000 km apart
    tlags = 0.01:6.01,
    cores = 8) # 0 days to 6 days

```


```{r}


G <- auto_basis(data = measures[,c("lon","lat")] %>%  # Take Tmax
                       SpatialPoints(),           # To sp obj
                nres = 1,                         # One resolution
                type = "Gaussian")                # Gaussian BFs

## ------------------------------------------------------------------------
S <- eval_basis(basis = G,                     # basis functions
                s = measures[,c("lon","lat")] %>%  # spat locations
                     as.matrix()) %>%          # conv. to matrix
     as.matrix()                               # results as matrix
colnames(S) <- paste0("B", 1:ncol(S)) # assign column names
```




```{r}
meas2 <- cbind(measures, S) %>% select(-date)
fit <- lm(value~(t+lat+lon)^2 +., data=meas2 %>% select(-loc))
meas2$residuals = residuals(fit)


res_filt <- meas2 %>% filter(t >= 31 & t <= 38)

residual_plot <- ggplot(res_filt) +             # plot points
    geom_point(aes(x = lon, y = lat,       # lon and lat
                   colour = residuals),           # attribute color
               size = 2) +                # make all points larger
    col_scale(name = "PM2.5") +            # attach color scale
    xlab("Longitude (deg)") +             # x-axis label
    ylab("Latitude (deg)") +              # y-axis label
    geom_path(data = map_data('france'),   # add US states map
          aes(x = long, y = lat, group = group)) +
    facet_wrap(~t, nrow=2) +               # facet by time
    coord_fixed(xlim = c(-5, 10),
                ylim = c(41, 53))  +      # zoom in
    theme_bw()                            # B&W theme

residual_plot

```


```{r}
STObj@data <- left_join(STObj@data, meas2)

vv <- variogram(object = residuals~1, # fixed effect component
    data = STObj, # July data
    width = 50, # spatial bin (80 km)
    cutoff = 100, # consider pts < 1000 km apart
    tlags = 0.01:6.01,
    cores = 8) # 0 days to 6 days

```


```{r}
P <- list()                                 # init list
days <- c(1:300)                      # set of days
for(i in seq_along(days)) {                 # for each day
  m_Day <- filter(meas2,
                     t == days[i])        # filter by day
  station.dists <- m_Day %>%             # take the data
    select(lon, lat) %>%                    # extract coords.
    dist() %>%                              # comp. dists.
    as.matrix()                             # conv. to matrix
  station.dists.inv <- 1/station.dists      # weight matrix
  diag(station.dists.inv) <- 0              # 0 on diag
  P[[i]] <- Moran.I(m_Day$residuals,     # run Moran's I
                    station.dists.inv) %>%
            do.call("cbind", .)             # conv. to df
}

## ------------------------------------------------------------------------
pfull <- do.call("rbind", P) 


# There IS spatial dependency!
hist(pfull[,4])



## ------------------------------------------------------------------------
station.dists <- meas2 %>%  # take the data
  select(lon, lat, t) %>%      # extract coordinates
  dist() %>%                     # compute distances
  as.matrix()                    # convert to matrix

## ------------------------------------------------------------------------
station.dists.inv <- 1/station.dists
diag(station.dists.inv) <- 0
Moran.I(meas2$residuals, station.dists.inv)$p.value

```



```{r}

```

